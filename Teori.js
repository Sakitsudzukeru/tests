const log = console.log;

//TODO:
// Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.
// Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value).
//Для примитивных значений работает очевидным образом.
// Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

// Преобразование подчиняется правилам:
// Значение	Становится…
// undefined -	NaN
// null	- 0
// true / false -	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0,
//иначе из непустой строки «считывается» число. При ошибке результат NaN.

// Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
// Подчиняется правилам:
// Значение	Становится…
// 0, null, undefined, NaN, ""	- false
// любое другое значение	- true

//TODO: Функции
// Объявление функции имеет вид:

// function имя(параметры, через, запятую) {
//   /* тело, код функции */
// }

// Передаваемые значения копируются в параметры функции и становятся локальными переменными.
// Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
// Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.

// Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций,
// не пользоваться внешними переменными.

// Функция, которая получает параметры, работает с ними и затем возвращает результат,
// гораздо понятнее функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

//TODO: Function Expression

// Function Declaration (Объявление Функции):

// function sayHi() {
//   alert( "Привет" );
// }

// Function Expression (Функциональное Выражение).

// let sayHi = function() {
//   alert( "Привет" );
// };

// Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
// Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration.
// Если функция была создана как часть выражения, то считается, что эта функция объявлена при помощи Function Expression.
// Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
// Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.

//TODO: Стрелочные функции
// Стрелочные функции очень удобны для простых действий, особенно для однострочных.

// Они бывают двух типов:

// Без фигурных скобок: (...args) => expression – правая сторона выражение: функция вычисляет его и возвращает результат.
// Скобки можно не ставить, если аргумент только один: n => n * 2.
// С фигурными скобками: (...args) => { body } – скобки позволяют нам писать несколько инструкций внутри функции,
// но при этом необходимо явно вызывать return, чтобы вернуть значение.

//TODO: Объекты
// Объекты же используются для хранения коллекций различных значений и более сложных сущностей.
// В JavaScript объекты используются очень часто, это одна из основ языка. Поэтому мы должны понять их, прежде чем углубляться куда-либо ещё.

// Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – это пара «ключ: значение»,
// где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.

// Мы можем представить объект в виде ящика с подписанными папками.
// Каждый элемент данных хранится в своей папке, на которой написан ключ.
// По ключу папку легко найти, удалить или добавить в неё что-либо.

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"

// Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.
// let fruit = prompt("Какой фрукт купить?", "apple");
// let bag = {
//   [fruit]: 5,
// };
// console.log(bag.apple);
//Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает (user["likes birds"])

// Последнее свойство объекта может заканчиваться запятой:
// let user = {
//   name: "John",
//   age: 30,
// }
// Это называется «висячая запятая».
// Такой подход упрощает добавление, удаление и перемещение свойств, так как все строки объекта становятся одинаковыми.

// Объект, объявленный через const, может быть изменён.
// Дело в том, что объявление const защищает от изменений только саму переменную user, а не её содержимое.
// Определение const выдаст ошибку только если мы присвоим переменной другое значение: user=....

// Проверка существования свойства, оператор «in»
// В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству.
// Даже если свойства не существует – ошибки не будет!

//TODO: Цикл «for…in»
// Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).

// for (key in object) {
//   // тело цикла выполняется для каждого свойства объекта
// }
// let codes = {
//   "+49": "Germany",
//   "+41": "Chine",
//   "+4": "USA",
//   "+1": "Russian",
// };

// for (let code in codes) {
//   console.log(+code);
// }

//TODO: Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
// Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

// Они хранят свойства (пары ключ-значение), где:

// Ключи свойств должны быть строками или символами (обычно строками).
// Значения могут быть любого типа.
// Чтобы получить доступ к свойству, мы можем использовать:

// Запись через точку: obj.property.
// Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
// Дополнительные операторы:

//TODO: Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for for (let key in obj).
// То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

// В JavaScript есть много других типов объектов:

// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.
// У них есть свои особенности, которые мы изучим позже.
// Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date»,
// но формально они не являются отдельными типами, а относятся к типу данных Object.
//  Они лишь расширяют его различными способами.

// Объекты в JavaScript очень мощные.
// Здесь мы только немного углубились в действительно огромную тему.
// Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.

//TODO:  Флаги свойств
// Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).

// writable – если true, свойство можно изменить, иначе оно только для чтения.
// enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
// configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
// const s = {
//   a: 100,
//   b: 160,
//   c: 130,
// };
// let sum = 0;

// for (let key in s) {
//   console.log((sum += s[key]));
// }

// TODO: Общее число элементов массива содержится в его свойстве length
// let f = ["Apple", "orange", "strobary"];
// console.log(f.length);

// TODO: Получение последних элементов при помощи «at»
// let f = ["Apple", "two", "4"];
// console.log(f.at(-1));
//Другими словами, arr.at(i):
// это ровно то же самое, что и arr[i], если i >= 0.
// для отрицательных значений i, он отступает от конца массива.

//TODO: Методы pop/push, shift/unshift
// Очередь – один из самых распространённых вариантов применения массива.
// В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:

//TODO: push добавляет элемент в конец.
//TODO: shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

// Существует и другой вариант применения для массивов – структура данных, называемая стек.

// Она поддерживает два вида операций:

//TODO: push добавляет элемент в конец.
//TODO: pop удаляет последний элемент.

// pop
// Удаляет последний элемент из массива и возвращает его:
// // let f = ["Apple", "home", "two", "1"];
// console.log(f.pop());
// push добавляет элемент в конец
// f.push("horse");
// console.log(f);
//shift
//Удаляет из массива первый элемент и возвращает его
// console.log(f.shift());
// console.log(f);
//TODO: unshift добавляет элемент в начало массива
// console.log(f.unshift("cat"));
// console.log(f);

//TODO: Массив – это особый подвид объектов. Квадратные скобки, используемые для того,
// чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу,
// как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.

// Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных,
// а также свойство length. Но в основе всё равно лежит объект.
// Массив является объектом и, следовательно, ведёт себя как объект.

// Например, копируется по ссылке:
// let f = ["apple"];
// let arr = f;
// console.log(arr === f);
// arr.push("cat");
// console.log(f);

//TODO: Перебор элементов for..of
// let f = ["Apple", "home", "two", "1"];
// for (let ff of f) {
//   console.log(ff);
// }
// Цикл for..of не предоставляет доступа к номеру текущего элемента,
// только к его значению, но в большинстве случаев этого достаточно. А также это короче.

//TODO: самый простой способ очистить массив – это arr.length = 0;

//TODO: Многомерные массивы
// Массивы могут содержать элементы, которые тоже являются массивами.
// Это можно использовать для создания многомерных массивов, например, для хранения матриц
// let m = [
//   [1, 2, 3],
//   [4, 5, 6],
//   [7, 8, 9],
// ];
// console.log(m[1][1]);

//TODO: toString
// Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.
// let arr = [1, 2, 3];
// console.log(arr);
// console.log(String(arr) === "1,2,3");

// let arr = [1, 2, 3];
// console.log(arr);
// console.log(String(arr) === "1,2,3");

//TODO: Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.
//arr.splice(index[, deleteCount, elem1, ..., elemN])
//Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
//Возвращает массив из удалённых элементов.

// let arr = ["I", "lesson", "Js", "now", "very now"];
// arr.splice(0, 3, "go", "danse");
// console.log(arr);

// let arr = ["1", "2", "4"];
// // с позиции 2
// // удалить 0 элементов
// // вставить "3"
// arr.splice(2, 0, "3");
// console.log(arr);

//TODO: Метод slice
//arr.slice([start], [end])
// Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
// Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.

// Это похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.
// let arr=[
//     't', 'e', 's', 't'
// ]
// console.log(arr.slice(1,3))// e,s (копирует с 1 до 3)
// console.log(arr.sl)// s,t (копирует с -2 до конца)

//TODO:  Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr.
//  Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.

//TODO:concat
//Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
//arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

// В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…

// Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.
// let arr = [1, 2];
// console.log(arr.concat([3, 4]));
// console.log(arr.concat([3, 4], [5, 6]));
// console.log([3, 4], 5, 6);

//TODO: Перебор: forEach
//Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
// arr.forEach(function(item, index, array) {
// ... делать что-то с item });
//выведет на экран каждый элемент массива
// ["b", "g", "n"].forEach(console.log);
// ["biblo", "gandalf", "nazgul"].forEach((item, index, arr) => {
//   console.log(`${item} имеет позицию ${index} в ${arr}`);
// });

//TODO: Поиск в массиве
//Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое,
//что и их строковые аналоги, но работают с элементами вместо символов
// arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
// arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
// arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

// let arr = [1, 0, false];
// console.log(arr.indexOf(0));
// console.log(arr.indexOf(-1));
// console.log(arr.includes(1));

//TODO: find и findIndex
// let result = arr.find(function (item, index, array) {
//   // если true - возвращается текущий элемент и перебор прерывается
//   // если все итерации оказались ложными, возвращается undefined
// });
// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
// let u = [
//   { id: 1, name: "oleg" },
//   { id: 2, name: "petya" },
//   { id: 3, name: "masha" },
// ];
// let us = u.find((item) => item.id == 1);
// console.log(u.name);

// let somUs = u.filter((item) => item.id < 3);
// console.log(somUs.length);

//TODO: Преобразование массива MAP
//Метод map() массивов JavaScript применяет указанную функцию последовательно к каждому элементу массива и создает новый массив из результатов.

//Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
//Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
// Метод .map() используется в том случае, если нужно сделать следующее:

// Надо выполнить над каждым элементом итерируемого объекта некую последовательность действий.
// Надо вернуть значение, которое, предположительно, было изменено.

// let result = arr.map(function (item, index, array) {
//   // возвращается новое значение вместо элемента
// });

// let lengths = ["biblo", "gandalf", "nazgul"].map((item) => item.length);
// console.log(lengths);

// let arr = [1, 4, 6, 7];
// let newArr = arr.map((i) => i + i);
// log(newArr);

//TODO: sort(fn)
// Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.

// Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
// const cn = (a, b) => {
//   if (a > b) return 1;
//   if (a == b) return 0;
//   if (a < b) return -1;
// };
// // let arr = [1, 2, 15];
// // arr.sort(cn);
// // log(arr);

// [1, , -2, 6, 2, 0, 8, -10].sort(function (a, b) {
//   log(a + "<>" + b);
// });

//TODO: reverse
//Метод arr.reverse меняет порядок элементов в arr на обратный.

// let arr = [1, 2, 3, 4, 5];
// arr.reverse();
// log(arr);

//TODO: split
//Метод split() разбивает объект String на массив строк путём разделения строки указанной подстрокой.
//Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.
// Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех,
// кому его отправить, через запятую: Вася, Петя, Маша.
//  Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как его получить?
// let names = "vasy, pety, maha";
// let arr = names.split(",");
// for (let name of arr) {
//   log(`messange check: ${name}.`);
// }

//TODO: join
//Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.
// let arr = ["vasy", "pety", "maha"];
// let str = arr.join(";");
// log(str);

//TODO: reduce/reduceRight
//Если нам нужно перебрать массив – мы можем использовать forEach, for или for..of.
//Если нам нужно перебрать массив и вернуть данные для каждого элемента – мы используем map.
//Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее.
//Они используются для вычисления какого-нибудь единого значения на основе всего массива.

//let value = arr.reduce(function(previousValue, item, index, array) {
// ...}, [initial]);

// previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его индекс,
// array – сам массив.

// let arr = [1, 3, 2, 4, 5];
// let res = arr.reduce((sum, current) => sum + current, 0);
// log(res);

//TODO: Symbol.iterator
// Чтобы сделать range итерируемым (и позволить for..of работать с ним),
// нам нужно добавить в объект метод с именем Symbol.iterator (специальный встроенный Symbol, созданный как раз для этого).
// let range = {
//   from: 1,
//   to: 5,
// };

// // 1. вызов for..of сначала вызывает эту функцию
// range[Symbol.iterator] = function () {
//   // ...она возвращает объект итератора:
//   // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
//   return {
//     current: this.from,
//     last: this.to,

//     // 3. next() вызывается на каждой итерации цикла for..of
//     next() {
//       // 4. он должен вернуть значение в виде объекта {done:.., value :...}
//       if (this.current <= this.last) {
//         return { done: false, value: this.current++ };
//       } else {
//         return { done: true };
//       }
//     },
//   };
// };

// // теперь работает!
// for (let num of range) {
//   log(num); // 1, затем 2, 3, 4, 5
// }

//TODO: Итерируемые объекты и псевдомассивы
// Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
// Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.

//TODO: Map
//Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
// Методы и свойства:

// new Map() – создаёт коллекцию.
// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
// map.size – возвращает текущее количество элементов.

// let map = new Map();

// map.set("1", "str1");
// map.set(1, "num1");
// map.set(true, "bool1");

// log(map.get(1));
// log(map.get("1"));
// log(map.get(map.size));

//Map может использовать объекты в качестве ключей.
// let john = { name: "john" };
// let visCountMap = new Map();

// visCountMap.set(john, 123);
// log(visCountMap.get(john));

// let john = { name: "john" };
// let visCountObj = {};
// visCountObj[john] = 123;
// log(visCountObj["[object Object]"]);

// Как объект Map сравнивает ключи
// Чтобы сравнивать ключи, объект Map использует алгоритм SameValueZero.
// Это почти такое же сравнение, что и ===, с той лишь разницей, что NaN считается равным NaN.
//  Так что NaN также может использоваться в качестве ключа.

// Этот алгоритм не может быть заменён или модифицирован.

//TODO: Перебор Map
// Для перебора коллекции Map есть 3 метода:

// map.keys() – возвращает итерируемый объект по ключам,
// map.values() – возвращает итерируемый объект по значениям,
// map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

// let recipeMap = new Map([
//   ["ogurez", 500],
//   ["tomato", 350],
//   ["luk", 50],
// ]);

// // перебор по ключам (овощи)
// for (let vegetable of recipeMap.keys()) {
//   log(vegetable);
// }

// // перебор по значениям (числа)
// for (let amount of recipeMap.values()) {
//   log(amount);
// }
// // перебор по элементам в формате [ключ, значение]
// for (let entry of recipeMap) {
//   log(entry);
// }

//TODO: Set
// Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

// Его основные методы это:
// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив),
// то копирует его значения в новый Set.
// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
// set.clear() – удаляет все имеющиеся значения.
// set.size – возвращает количество элементов в множестве.

// let set = new Set();
// let jo = { name: "jo" };
// let pe = { name: "pe" };
// let ma = { name: "ma" };

// set.add(jo);
// set.add(pe);
// set.add(ma);
// set.add(jo);
// set.add(ma);
// log(set.size);
// for (let us of set) {
//   log(us.name);s
// }

//TODO: перебор значений свойств в цикле
// let us = {
//   name: "jo",
//   age: 30,
// };
// for (let value of Object.values(us)) {
//   console.log(value);
// }

//TODO: Методы объекта, "this"
// let us = { name: "jo" };
// let ad = { name: "pe" };

// function say() {
//   log(this.name);
// }
// us.say;
// ad.say;
// В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования.
// Оно может использоваться в любой функции.

//TODO: == - приводит к одному типу данных; === - не приводит к одному типу данных;
//TODO: toFixed() -количество знаков после запятой;
//TODO: parseFloat/Int()
//TODO: rest/.../ собирает все значения
