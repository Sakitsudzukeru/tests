//TODO: Ключевое слово this
//this - это объект, свойством которого является функция;
//this - дает функциям доступ к своему объекту и его свойствам;
//this - помогает выполнить один и тот же код для нескольких объектов;
//this - можно рассматривать как кто меня вызвал?; т.е. то, что находится слева от точки. Например, window.a();
//this - имеет динамическую область, т. е. не важно, где он был написан, важно, где он был вызван.

// const obj = {
//   name: "Alex",
//   sing() {
//     console.log("a this", this);
//     //Стрелочные функции связывают this с лексической областью действия.
//     // var anotherFunc = function () {
//     var anotherFunc = () => {
//       console.log("b this ", this);
//     };
//     anotherFunc();
//   },
// };

// obj.sing();

//TODO:Прототип (prototype) - это экземпляр рабочего объекта. Объекты наследуются напрямую от других объектов.
//__proto__ является ссылкой на свойство прототипа родительского объекта, например:

//Свойство prototype принадлежит только функциям, в частности, функциям конструктора. Конструктор Object создает обертку объекта.
//Свойства proto и prototype используются для создания цепочки наследования свойств между объектами, начиная с Object и Primitive Types.
//Object.create() можно использовать для создания объектов с его свойством proto, связанным со свойством prototype объекта, переданного в качестве аргумента Object.create().
//Object - это базовая функция (конструктор). Корнем всего в JavaScript является Object, который на самом деле является функцией

//TODO: Классы
//Ключевое слово class в JS - синтаксический сахар. Под капотом он всё еще использует прототипное наследование (prototypal inheritance).
//Экземпляры класса должны создаваться с ключевым словом new.
//Метод constructor используется для создания экземпляра state (данных) нового объекта. State обычно уникально для каждого экземпляра.
//Функции обычно не включаются в конструктор, так как они создают ссылку на место в памяти в каждом новом экземпляре класса.
//Таким образом используя больше памяти, чем необходимо. Включая функции в качестве методов класса,
//экземпляры класса могут ссылаться на функцию через цепочку прототипов.
//Прототипное наследование (prototypal inheritance) имеет лучшую эффективность памяти,
//чем классическое наследование, благодаря тому, что оно разделяет ссылки памяти своих свойств прототипа с теми объектами,
//которые наследуют от него. В классическом наследовании, экземпляры класса создают новые ссылки на память для каждого унаследованного свойства.

//TODO: Инкапсуляция
//включает в себя идею о том, что данные объекта не должны быть напрямую доступны; нужно вызывать методы вместо прямого доступа к данным;
//инкапсуляция позволяет скрывать/показывать свойства функций

// const CreateCouter = () => {
//   // Переменная, определенная в области действия фабрики или конструктора
//   // является приватной для этой функции.
//   let count = 0;
//   return {
//     // Любые другие функции, определенные в той же области, являются привилегированными:
//     // Они имеют доступ к закрытой переменной `count`
//     // определенной в любом месте их цепочки областей видимости (содержащей области действия функции).
//     click: () => (count += 1),
//     getCount: () => count.toLocaleString(),
//   };
// };

// const counter = CreateCouter();
// counter.click();
// counter.click();
// console.log("Инкапсуляция: " + counter.getCount());

//TODO: Абстракция
//способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения, из более сложной модели;
//иными словами - способ скрыть детали реализации и показать пользователям только функциональность;
//нельзя создать экземпляр абстрактного класса

//TODO: Полиморфизм
//вызов одного и того же метода для разных объектов, при этом каждый объект реагирует по-своему

// class Human {
//   constructor(name) {
//     this.name = name;
//   }

//   say() {
//     return `Hello, my name is ${this.name}, I like travelling `;
//   }
// }

// class Men extends Human {
//   constructor(name) {
//     super(name);
//   }
//   // Берем метод say у родителя.
// }

// class Coder extends Human {
//   constructor(name) {
//     super(name);
//   }

//   say() {
//     // Переопределяем метод родителя say для отображения нового значения.
//     return `Hello, my name is ${this.name}, I like travelling `;
//   }
// }

// const alex = new Men("Alex");
// const leo = new Coder("Leo");

// console.log(alex.say());
// console.log(leo.say());

//TODO: Наследование
//механизм базирования объекта или class на другом объекте (наследование на основе прототипа) или class (наследование на основе класса)

// class Human {
//   constructor(name) {
//     this.name = name;
//   }

//   sayMyName() {
//     return "Hello, I " + this.name;
//   }
// }

// class Men extends Human {
//   constructor(name) {
//     super(name);
//   }
// }

// class Coder extends Human {
//   constructor(name) {
//     super(name);
//   }
// }

// const alex = new Men("Alex");
// const leo = new Coder("Leo");

// console.log(alex.sayMyName());
// console.log(leo.sayMyName());
